{"ast":null,"code":"import { executeQuery } from './neo4jConnection';\n\n// Fonction pour vérifier une hypothèse\nexport function checkHypothesis(suspect, weapon, room) {\n  const query = `\n        MATCH (s:Person {name: '${suspect}'})-[:MYSTERY]->(w:Weapon {name: '${weapon}'}), \n              (w)-[:MYSTERY]->(r:Room {name: '${room}'})\n        RETURN s, w, r`;\n  return executeQuery(query).then(result => result.records.length > 0);\n}\n\n// Fonction pour obtenir l'état initial du plateau\nexport function getInitialState() {\n  const query = `\n        MATCH (p:Person)-[:IN]->(r:Room)\n        RETURN p, r`;\n  return executeQuery(query).then(result => {\n    // Organiser les données par salles\n    const rooms = {};\n    result.records.forEach(record => {\n      const person = record.get('p').properties;\n      const room = record.get('r').properties.name;\n      if (!rooms[room]) rooms[room] = {\n        name: room,\n        occupants: []\n      };\n      rooms[room].occupants.push(person);\n    });\n    return Object.values(rooms); // Retourne une liste des salles avec leurs occupants\n  });\n}","map":{"version":3,"names":["executeQuery","checkHypothesis","suspect","weapon","room","query","then","result","records","length","getInitialState","rooms","forEach","record","person","get","properties","name","occupants","push","Object","values"],"sources":["C:/Users/gelgo/Documents/IUT/BUT3/R5.10 - Nouveaux paradigmes de BDD/cluedo-game/src/gameLogic.js"],"sourcesContent":["import { executeQuery } from './neo4jConnection';\r\n\r\n// Fonction pour vérifier une hypothèse\r\nexport function checkHypothesis(suspect, weapon, room) {\r\n    const query = `\r\n        MATCH (s:Person {name: '${suspect}'})-[:MYSTERY]->(w:Weapon {name: '${weapon}'}), \r\n              (w)-[:MYSTERY]->(r:Room {name: '${room}'})\r\n        RETURN s, w, r`;\r\n\r\n    return executeQuery(query).then(result => result.records.length > 0);\r\n}\r\n\r\n// Fonction pour obtenir l'état initial du plateau\r\nexport function getInitialState() {\r\n    const query = `\r\n        MATCH (p:Person)-[:IN]->(r:Room)\r\n        RETURN p, r`;\r\n\r\n    return executeQuery(query).then(result => {\r\n        // Organiser les données par salles\r\n        const rooms = {};\r\n        result.records.forEach(record => {\r\n            const person = record.get('p').properties;\r\n            const room = record.get('r').properties.name;\r\n            if (!rooms[room]) rooms[room] = { name: room, occupants: [] };\r\n            rooms[room].occupants.push(person);\r\n        });\r\n        return Object.values(rooms); // Retourne une liste des salles avec leurs occupants\r\n    });\r\n}\r\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,mBAAmB;;AAEhD;AACA,OAAO,SAASC,eAAeA,CAACC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACnD,MAAMC,KAAK,GAAG;AAClB,kCAAkCH,OAAO,qCAAqCC,MAAM;AACpF,gDAAgDC,IAAI;AACpD,uBAAuB;EAEnB,OAAOJ,YAAY,CAACK,KAAK,CAAC,CAACC,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACC,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC;AACxE;;AAEA;AACA,OAAO,SAASC,eAAeA,CAAA,EAAG;EAC9B,MAAML,KAAK,GAAG;AAClB;AACA,oBAAoB;EAEhB,OAAOL,YAAY,CAACK,KAAK,CAAC,CAACC,IAAI,CAACC,MAAM,IAAI;IACtC;IACA,MAAMI,KAAK,GAAG,CAAC,CAAC;IAChBJ,MAAM,CAACC,OAAO,CAACI,OAAO,CAACC,MAAM,IAAI;MAC7B,MAAMC,MAAM,GAAGD,MAAM,CAACE,GAAG,CAAC,GAAG,CAAC,CAACC,UAAU;MACzC,MAAMZ,IAAI,GAAGS,MAAM,CAACE,GAAG,CAAC,GAAG,CAAC,CAACC,UAAU,CAACC,IAAI;MAC5C,IAAI,CAACN,KAAK,CAACP,IAAI,CAAC,EAAEO,KAAK,CAACP,IAAI,CAAC,GAAG;QAAEa,IAAI,EAAEb,IAAI;QAAEc,SAAS,EAAE;MAAG,CAAC;MAC7DP,KAAK,CAACP,IAAI,CAAC,CAACc,SAAS,CAACC,IAAI,CAACL,MAAM,CAAC;IACtC,CAAC,CAAC;IACF,OAAOM,MAAM,CAACC,MAAM,CAACV,KAAK,CAAC,CAAC,CAAC;EACjC,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}