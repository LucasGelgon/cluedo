{"ast":null,"code":"import { executeQuery } from './neo4jConnection';\n\n// Variable pour stocker les informations sur le crime\nlet crime = {\n  suspect: '',\n  weapon: '',\n  room: ''\n};\n\n// Fonction pour récupérer l'état initial\nexport async function getInitialState() {\n  try {\n    const result = await executeQuery(`\n            MATCH (s:Person), (w:Weapon), (r:Room)\n            WITH s, w, r\n            ORDER BY rand()\n            RETURN s.name AS suspect, w.name AS weapon, r.name AS room\n            LIMIT 1\n        `);\n    console.log('Données récupérées:', result);\n    if (!result || !Array.isArray(result) || result.length === 0) {\n      throw new Error('Aucun crime trouvé. Vérifiez que vous avez des suspects, des armes et des pièces dans la base de données.');\n    }\n    const randomCrime = result[0].row;\n    crime = {\n      suspect: randomCrime[0] || '',\n      weapon: randomCrime[1] || '',\n      room: randomCrime[2] || ''\n    };\n    console.log('Crime choisi :', crime);\n  } catch (error) {\n    console.error('Erreur lors de la récupération des données:', error);\n    return []; // Retournez un tableau vide en cas d'erreur\n  }\n}\n\n// Fonction pour vérifier l'hypothèse\nexport const checkHypothesis = async (suspect, weapon, room, onGameOver) => {\n  try {\n    const isSuspectCorrect = suspect === crime.suspect;\n    const isWeaponCorrect = weapon === crime.weapon;\n    const isRoomCorrect = room === crime.room;\n\n    // Afficher les résultats pour chaque élément\n    if (isSuspectCorrect) {\n      alert(\"Le suspect est correct !\");\n    } else {\n      alert(\"Le suspect est incorrect !\");\n    }\n    if (isWeaponCorrect) {\n      alert(\"L'arme est correcte !\");\n    } else {\n      alert(\"L'arme est incorrecte !\");\n    }\n    if (isRoomCorrect) {\n      alert(\"La salle est correcte !\");\n    } else {\n      alert(\"La salle est incorrecte !\");\n    }\n\n    // Vérifiez si toutes les hypothèses sont correctes\n    if (isSuspectCorrect && isWeaponCorrect && isRoomCorrect) {\n      alert(\"Vous avez gagné ! Vous avez trouvé le crime !\");\n      onGameOver(); // Terminez le jeu\n    }\n  } catch (error) {\n    console.error('Erreur lors de la vérification de l\\'hypothèse:', error);\n  }\n};\n\n// Fonction pour mettre à jour les informations sur le crime\nexport const setCrimeData = newCrime => {\n  crime = newCrime;\n};","map":{"version":3,"names":["executeQuery","crime","suspect","weapon","room","getInitialState","result","console","log","Array","isArray","length","Error","randomCrime","row","error","checkHypothesis","onGameOver","isSuspectCorrect","isWeaponCorrect","isRoomCorrect","alert","setCrimeData","newCrime"],"sources":["C:/Users/gelgo/Documents/IUT/BUT3/R5.10 - Nouveaux paradigmes de BDD/cluedo-game/src/gameLogic.js"],"sourcesContent":["import { executeQuery } from './neo4jConnection';\r\n\r\n// Variable pour stocker les informations sur le crime\r\nlet crime = { suspect: '', weapon: '', room: '' };\r\n\r\n// Fonction pour récupérer l'état initial\r\nexport async function getInitialState() {\r\n    try {\r\n        const result = await executeQuery(`\r\n            MATCH (s:Person), (w:Weapon), (r:Room)\r\n            WITH s, w, r\r\n            ORDER BY rand()\r\n            RETURN s.name AS suspect, w.name AS weapon, r.name AS room\r\n            LIMIT 1\r\n        `);\r\n        \r\n        console.log('Données récupérées:', result);\r\n\r\n        if (!result || !Array.isArray(result) || result.length === 0) {\r\n            throw new Error('Aucun crime trouvé. Vérifiez que vous avez des suspects, des armes et des pièces dans la base de données.');\r\n        }\r\n\r\n        const randomCrime = result[0].row;\r\n        crime = {\r\n            suspect: randomCrime[0] || '',\r\n            weapon: randomCrime[1] || '',\r\n            room: randomCrime[2] || ''\r\n        };\r\n\r\n        console.log('Crime choisi :', crime);\r\n\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des données:', error);\r\n        return []; // Retournez un tableau vide en cas d'erreur\r\n    }\r\n}\r\n\r\n\r\n// Fonction pour vérifier l'hypothèse\r\nexport const checkHypothesis = async (suspect, weapon, room, onGameOver) => {\r\n    try {\r\n        const isSuspectCorrect = suspect === crime.suspect;\r\n        const isWeaponCorrect = weapon === crime.weapon;\r\n        const isRoomCorrect = room === crime.room;\r\n\r\n        // Afficher les résultats pour chaque élément\r\n        if (isSuspectCorrect) {\r\n            alert(\"Le suspect est correct !\");\r\n        } else {\r\n            alert(\"Le suspect est incorrect !\");\r\n        }\r\n\r\n        if (isWeaponCorrect) {\r\n            alert(\"L'arme est correcte !\");\r\n        } else {\r\n            alert(\"L'arme est incorrecte !\");\r\n        }\r\n\r\n        if (isRoomCorrect) {\r\n            alert(\"La salle est correcte !\");\r\n        } else {\r\n            alert(\"La salle est incorrecte !\");\r\n        }\r\n\r\n        // Vérifiez si toutes les hypothèses sont correctes\r\n        if (isSuspectCorrect && isWeaponCorrect && isRoomCorrect) {\r\n            alert(\"Vous avez gagné ! Vous avez trouvé le crime !\");\r\n            onGameOver(); // Terminez le jeu\r\n        }\r\n    } catch (error) {\r\n        console.error('Erreur lors de la vérification de l\\'hypothèse:', error);\r\n    }\r\n};\r\n\r\n// Fonction pour mettre à jour les informations sur le crime\r\nexport const setCrimeData = (newCrime) => {\r\n    crime = newCrime;\r\n};\r\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,mBAAmB;;AAEhD;AACA,IAAIC,KAAK,GAAG;EAAEC,OAAO,EAAE,EAAE;EAAEC,MAAM,EAAE,EAAE;EAAEC,IAAI,EAAE;AAAG,CAAC;;AAEjD;AACA,OAAO,eAAeC,eAAeA,CAAA,EAAG;EACpC,IAAI;IACA,MAAMC,MAAM,GAAG,MAAMN,YAAY,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS,CAAC;IAEFO,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAEF,MAAM,CAAC;IAE1C,IAAI,CAACA,MAAM,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,IAAIA,MAAM,CAACK,MAAM,KAAK,CAAC,EAAE;MAC1D,MAAM,IAAIC,KAAK,CAAC,2GAA2G,CAAC;IAChI;IAEA,MAAMC,WAAW,GAAGP,MAAM,CAAC,CAAC,CAAC,CAACQ,GAAG;IACjCb,KAAK,GAAG;MACJC,OAAO,EAAEW,WAAW,CAAC,CAAC,CAAC,IAAI,EAAE;MAC7BV,MAAM,EAAEU,WAAW,CAAC,CAAC,CAAC,IAAI,EAAE;MAC5BT,IAAI,EAAES,WAAW,CAAC,CAAC,CAAC,IAAI;IAC5B,CAAC;IAEDN,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEP,KAAK,CAAC;EAExC,CAAC,CAAC,OAAOc,KAAK,EAAE;IACZR,OAAO,CAACQ,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;IACnE,OAAO,EAAE,CAAC,CAAC;EACf;AACJ;;AAGA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAAOd,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAEa,UAAU,KAAK;EACxE,IAAI;IACA,MAAMC,gBAAgB,GAAGhB,OAAO,KAAKD,KAAK,CAACC,OAAO;IAClD,MAAMiB,eAAe,GAAGhB,MAAM,KAAKF,KAAK,CAACE,MAAM;IAC/C,MAAMiB,aAAa,GAAGhB,IAAI,KAAKH,KAAK,CAACG,IAAI;;IAEzC;IACA,IAAIc,gBAAgB,EAAE;MAClBG,KAAK,CAAC,0BAA0B,CAAC;IACrC,CAAC,MAAM;MACHA,KAAK,CAAC,4BAA4B,CAAC;IACvC;IAEA,IAAIF,eAAe,EAAE;MACjBE,KAAK,CAAC,uBAAuB,CAAC;IAClC,CAAC,MAAM;MACHA,KAAK,CAAC,yBAAyB,CAAC;IACpC;IAEA,IAAID,aAAa,EAAE;MACfC,KAAK,CAAC,yBAAyB,CAAC;IACpC,CAAC,MAAM;MACHA,KAAK,CAAC,2BAA2B,CAAC;IACtC;;IAEA;IACA,IAAIH,gBAAgB,IAAIC,eAAe,IAAIC,aAAa,EAAE;MACtDC,KAAK,CAAC,+CAA+C,CAAC;MACtDJ,UAAU,CAAC,CAAC,CAAC,CAAC;IAClB;EACJ,CAAC,CAAC,OAAOF,KAAK,EAAE;IACZR,OAAO,CAACQ,KAAK,CAAC,iDAAiD,EAAEA,KAAK,CAAC;EAC3E;AACJ,CAAC;;AAED;AACA,OAAO,MAAMO,YAAY,GAAIC,QAAQ,IAAK;EACtCtB,KAAK,GAAGsB,QAAQ;AACpB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}