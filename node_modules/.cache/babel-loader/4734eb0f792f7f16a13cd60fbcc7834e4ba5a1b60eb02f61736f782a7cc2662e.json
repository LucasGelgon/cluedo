{"ast":null,"code":"import { executeQuery } from './neo4jConnection';\nlet crime = null;\nexport async function getInitialState() {\n  if (crime) return crime;\n  try {\n    const result = await executeQuery(`\n            MATCH (s:Person), (w:Weapon), (r:Room)\n            WITH s, w, r\n            ORDER BY rand()\n            RETURN s.name AS suspect, w.name AS weapon, r.name AS room\n            LIMIT 1\n        `);\n    if (!result || result.length === 0) {\n      throw new Error('Aucun crime trouvé.');\n    }\n    const record = result[0];\n    crime = {\n      suspect: record.suspect || '',\n      weapon: record.weapon || '',\n      room: record.room || ''\n    };\n    console.log('Crime choisi :', crime);\n    return crime;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des données:', error);\n    return null;\n  }\n}\nexport const checkHypothesis = (suspect, weapon, room, onGameOver) => {\n  if (!crime) {\n    console.error('Le crime n\\'a pas été initialisé');\n    return;\n  }\n  const isSuspectCorrect = suspect.trim().toLowerCase() === crime.suspect.trim().toLowerCase();\n  const isWeaponCorrect = weapon.trim().toLowerCase() === crime.weapon.trim().toLowerCase();\n  const isRoomCorrect = room.trim().toLowerCase() === crime.room.trim().toLowerCase();\n  return {\n    suspect: isSuspectCorrect,\n    weapon: isWeaponCorrect,\n    room: isRoomCorrect,\n    isCorrect: isSuspectCorrect && isWeaponCorrect && isRoomCorrect\n  };\n};","map":{"version":3,"names":["executeQuery","crime","getInitialState","result","length","Error","record","suspect","weapon","room","console","log","error","checkHypothesis","onGameOver","isSuspectCorrect","trim","toLowerCase","isWeaponCorrect","isRoomCorrect","isCorrect"],"sources":["C:/Users/gelgo/Documents/IUT/BUT3/R5.10 - Nouveaux paradigmes de BDD/cluedo-game/src/gameLogic.js"],"sourcesContent":["import { executeQuery } from './neo4jConnection';\r\n\r\nlet crime = null;\r\n\r\nexport async function getInitialState() {\r\n    if (crime) return crime;\r\n\r\n    try {\r\n        const result = await executeQuery(`\r\n            MATCH (s:Person), (w:Weapon), (r:Room)\r\n            WITH s, w, r\r\n            ORDER BY rand()\r\n            RETURN s.name AS suspect, w.name AS weapon, r.name AS room\r\n            LIMIT 1\r\n        `);\r\n        \r\n        if (!result || result.length === 0) {\r\n            throw new Error('Aucun crime trouvé.');\r\n        }\r\n\r\n        const record = result[0];\r\n        \r\n        crime = {\r\n            suspect: record.suspect || '',\r\n            weapon: record.weapon || '',\r\n            room: record.room || ''\r\n        };\r\n\r\n        console.log('Crime choisi :', crime);\r\n        return crime;\r\n    } catch (error) {\r\n        console.error('Erreur lors de la récupération des données:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport const checkHypothesis = (suspect, weapon, room, onGameOver) => {\r\n    if (!crime) {\r\n        console.error('Le crime n\\'a pas été initialisé');\r\n        return;\r\n    }\r\n\r\n    const isSuspectCorrect = suspect.trim().toLowerCase() === crime.suspect.trim().toLowerCase();\r\n    const isWeaponCorrect = weapon.trim().toLowerCase() === crime.weapon.trim().toLowerCase();\r\n    const isRoomCorrect = room.trim().toLowerCase() === crime.room.trim().toLowerCase();\r\n\r\n    return {\r\n        suspect: isSuspectCorrect,\r\n        weapon: isWeaponCorrect,\r\n        room: isRoomCorrect,\r\n        isCorrect: isSuspectCorrect && isWeaponCorrect && isRoomCorrect\r\n    };\r\n};"],"mappings":"AAAA,SAASA,YAAY,QAAQ,mBAAmB;AAEhD,IAAIC,KAAK,GAAG,IAAI;AAEhB,OAAO,eAAeC,eAAeA,CAAA,EAAG;EACpC,IAAID,KAAK,EAAE,OAAOA,KAAK;EAEvB,IAAI;IACA,MAAME,MAAM,GAAG,MAAMH,YAAY,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS,CAAC;IAEF,IAAI,CAACG,MAAM,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;MAChC,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;IAC1C;IAEA,MAAMC,MAAM,GAAGH,MAAM,CAAC,CAAC,CAAC;IAExBF,KAAK,GAAG;MACJM,OAAO,EAAED,MAAM,CAACC,OAAO,IAAI,EAAE;MAC7BC,MAAM,EAAEF,MAAM,CAACE,MAAM,IAAI,EAAE;MAC3BC,IAAI,EAAEH,MAAM,CAACG,IAAI,IAAI;IACzB,CAAC;IAEDC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEV,KAAK,CAAC;IACpC,OAAOA,KAAK;EAChB,CAAC,CAAC,OAAOW,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;IACnE,OAAO,IAAI;EACf;AACJ;AAEA,OAAO,MAAMC,eAAe,GAAGA,CAACN,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAEK,UAAU,KAAK;EAClE,IAAI,CAACb,KAAK,EAAE;IACRS,OAAO,CAACE,KAAK,CAAC,kCAAkC,CAAC;IACjD;EACJ;EAEA,MAAMG,gBAAgB,GAAGR,OAAO,CAACS,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,KAAKhB,KAAK,CAACM,OAAO,CAACS,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAC5F,MAAMC,eAAe,GAAGV,MAAM,CAACQ,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,KAAKhB,KAAK,CAACO,MAAM,CAACQ,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EACzF,MAAME,aAAa,GAAGV,IAAI,CAACO,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,KAAKhB,KAAK,CAACQ,IAAI,CAACO,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAEnF,OAAO;IACHV,OAAO,EAAEQ,gBAAgB;IACzBP,MAAM,EAAEU,eAAe;IACvBT,IAAI,EAAEU,aAAa;IACnBC,SAAS,EAAEL,gBAAgB,IAAIG,eAAe,IAAIC;EACtD,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}